% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dbInsertDataMssql.R
\name{dbInsertDataMssql}
\alias{dbInsertDataMssql}
\title{Insert Data into SQL Server in Chunks with Transaction Support}
\usage{
dbInsertDataMssql(
  conn,
  new.data,
  schema.name,
  table.name,
  chunk.size = 10000L,
  overwrite = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{conn}{A valid SQL Server connection object (from \pkg{DBI}).}

\item{new.data}{A non-empty `data.frame` to insert.}

\item{schema.name}{A non-empty character string specifying the target schema name.}

\item{table.name}{A non-empty character string specifying the target table name.}

\item{chunk.size}{Integer, number of rows per chunk. Default is `10000`.}

\item{overwrite}{Logical; whether to overwrite an existing table. Default is `FALSE`.}

\item{verbose}{Logical; whether to print progress messages. Default is `TRUE`.}
}
\value{
A `data.frame` transaction log.
}
\description{
Inserts a `data.frame` into a SQL Server table in chunks. All chunks are
written within a single transaction. If any chunk fails, the entire operation
is rolled back. If all chunks succeed, the transaction is committed.
}
\details{
The function returns a transaction log as a `data.frame`. Each row records
a chunk insert or transaction event.

Transaction log columns:
\describe{
  \item{operation}{Type of operation ("insert", "commit", "rollback", "delete").}
  \item{chunk}{Chunk number (if applicable).}
  \item{rows}{Number of rows inserted or affected.}
  \item{start_row}{First row index of the chunk (if applicable).}
  \item{end_row}{Last row index of the chunk (if applicable).}
  \item{status}{Operation status ("success" or "failed").}
  \item{message}{Details or error messages.}
  \item{timestamp}{Time the operation was logged (POSIXct, UTC).}
}
}
\examples{
\dontrun{
log.df <- dbInsertDataMssql(
  conn = con,
  new.data = new.data,
  schema.name = "dbo",
  table.name = "events",
  chunk.size = 5000
)
}
}
